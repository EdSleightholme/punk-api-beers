{"ast":null,"code":"\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nexports.__esModule = true;\nexports[\"default\"] = initHeadManager;\n\nvar _react = require(\"react\");\n\nvar DOMAttributeNames = {\n  acceptCharset: 'accept-charset',\n  className: 'class',\n  htmlFor: 'for',\n  httpEquiv: 'http-equiv'\n};\n\nfunction reactElementToDOM(_ref) {\n  var type = _ref.type,\n      props = _ref.props;\n  var el = document.createElement(type);\n\n  for (var p in props) {\n    if (!props.hasOwnProperty(p)) continue;\n    if (p === 'children' || p === 'dangerouslySetInnerHTML') continue; // we don't render undefined props to the DOM\n\n    if (props[p] === undefined) continue;\n    var attr = DOMAttributeNames[p] || p.toLowerCase();\n    el.setAttribute(attr, props[p]);\n  }\n\n  var children = props.children,\n      dangerouslySetInnerHTML = props.dangerouslySetInnerHTML;\n\n  if (dangerouslySetInnerHTML) {\n    el.innerHTML = dangerouslySetInnerHTML.__html || '';\n  } else if (children) {\n    el.textContent = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';\n  }\n\n  return el;\n}\n\nfunction updateElements(elements, components, removeOldTags) {\n  var headEl = document.getElementsByTagName('head')[0];\n  var oldTags = new Set(elements);\n  components.forEach(function (tag) {\n    if (tag.type === 'title') {\n      var title = '';\n\n      if (tag) {\n        var children = tag.props.children;\n        title = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';\n      }\n\n      if (title !== document.title) document.title = title;\n      return;\n    }\n\n    var newTag = reactElementToDOM(tag);\n    var elementIter = elements.values();\n\n    while (true) {\n      // Note: We don't use for-of here to avoid needing to polyfill it.\n      var _elementIter$next = elementIter.next(),\n          done = _elementIter$next.done,\n          value = _elementIter$next.value;\n\n      if (value == null ? void 0 : value.isEqualNode(newTag)) {\n        oldTags[\"delete\"](value);\n        return;\n      }\n\n      if (done) {\n        break;\n      }\n    }\n\n    elements.add(newTag);\n    headEl.appendChild(newTag);\n  });\n  oldTags.forEach(function (oldTag) {\n    if (removeOldTags) {\n      oldTag.parentNode.removeChild(oldTag);\n    }\n\n    elements[\"delete\"](oldTag);\n  });\n}\n\nfunction initHeadManager(initialHeadEntries) {\n  var headEl = document.getElementsByTagName('head')[0];\n  var elements = new Set(headEl.children);\n  updateElements(elements, initialHeadEntries.map(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        type = _ref3[0],\n        props = _ref3[1];\n\n    return /*#__PURE__*/(0, _react.createElement)(type, props);\n  }), false);\n  var updatePromise = null;\n  return {\n    mountedInstances: new Set(),\n    updateHead: function updateHead(head) {\n      var promise = updatePromise = Promise.resolve().then(function () {\n        if (promise !== updatePromise) return;\n        updatePromise = null;\n        updateElements(elements, head, true);\n      });\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"script"}